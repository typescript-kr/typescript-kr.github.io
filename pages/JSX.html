
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>JSX · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight-1/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

    
    <link rel="stylesheet" type="text/css" href="../assets/css/atom-one-dark.css" />
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Decorators.html" />
    
    
    <link rel="prev" href="Declaration Merging.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    소개
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Tutorials</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="tutorials/TypeScript in 5 minutes.html">
            
                <a href="tutorials/TypeScript in 5 minutes.html">
            
                    
                    5분 안에 보는 TypeScript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="tutorials/ASP.NET Core.html">
            
                <a href="tutorials/ASP.NET Core.html">
            
                    
                    ASP.NET Core
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="tutorials/Gulp.html">
            
                <a href="tutorials/Gulp.html">
            
                    
                    걸프
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="tutorials/Migrating from JavaScript.html">
            
                <a href="tutorials/Migrating from JavaScript.html">
            
                    
                    JavaScript에서 마이그레이션
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="tutorials/React & Webpack.html">
            
                <a href="tutorials/React & Webpack.html">
            
                    
                    리액트 & 웹팩
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Handbook</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="Basic Types.html">
            
                <a href="Basic Types.html">
            
                    
                    기본 타입
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="Variable Declarations.html">
            
                <a href="Variable Declarations.html">
            
                    
                    변수 선언
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="Interfaces.html">
            
                <a href="Interfaces.html">
            
                    
                    인터페이스
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.4" data-path="Classes.html">
            
                <a href="Classes.html">
            
                    
                    클래스
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.5" data-path="Functions.html">
            
                <a href="Functions.html">
            
                    
                    함수
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.6" data-path="Generics.html">
            
                <a href="Generics.html">
            
                    
                    제네릭
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.7" data-path="Enums.html">
            
                <a href="Enums.html">
            
                    
                    열거형
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.8" data-path="Type Inference.html">
            
                <a href="Type Inference.html">
            
                    
                    타입 추론
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.9" data-path="Type Compatibility.html">
            
                <a href="Type Compatibility.html">
            
                    
                    타입 호환성
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.10" data-path="Advanced Types.html">
            
                <a href="Advanced Types.html">
            
                    
                    고급 타입
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.11" data-path="Symbols.html">
            
                <a href="Symbols.html">
            
                    
                    심볼
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.12" data-path="Iterators and Generators.html">
            
                <a href="Iterators and Generators.html">
            
                    
                    이터레이터와 제네레이터
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.13" data-path="Modules.html">
            
                <a href="Modules.html">
            
                    
                    Modules
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.14" data-path="Namespaces.html">
            
                <a href="Namespaces.html">
            
                    
                    Namespaces
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.15" data-path="Namespaces and Modules.html">
            
                <a href="Namespaces and Modules.html">
            
                    
                    Namespaces and Modules
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.16" data-path="Module Resolution.html">
            
                <a href="Module Resolution.html">
            
                    
                    Module Resolution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.17" data-path="Declaration Merging.html">
            
                <a href="Declaration Merging.html">
            
                    
                    Declaration Merging
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="3.18" data-path="JSX.html">
            
                <a href="JSX.html">
            
                    
                    JSX
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.19" data-path="Decorators.html">
            
                <a href="Decorators.html">
            
                    
                    Decorators
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.20" data-path="Mixins.html">
            
                <a href="Mixins.html">
            
                    
                    Mixins
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.21" data-path="Triple-Slash Directives.html">
            
                <a href="Triple-Slash Directives.html">
            
                    
                    Triple-Slash Directives
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.22" data-path="Type Checking JavaScript Files.html">
            
                <a href="Type Checking JavaScript Files.html">
            
                    
                    Type Checking JavaScript Files
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Declaration Files</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="declaration files/Introduction.html">
            
                <a href="declaration files/Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="declaration files/Library Structures.html">
            
                <a href="declaration files/Library Structures.html">
            
                    
                    Library Structures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="declaration files/By Example.html">
            
                <a href="declaration files/By Example.html">
            
                    
                    By Example
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.4" data-path="declaration files/Do's and Don'ts.html">
            
                <a href="declaration files/Do's and Don'ts.html">
            
                    
                    Do's and Don'ts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.5" data-path="declaration files/Deep Dive.html">
            
                <a href="declaration files/Deep Dive.html">
            
                    
                    Deep Dive
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.6" data-path="declaration files/Templates.html">
            
                <a href="declaration files/Templates.html">
            
                    
                    Templates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.7" data-path="declaration files/Publishing.html">
            
                <a href="declaration files/Publishing.html">
            
                    
                    Publishing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.8" data-path="declaration files/Consumption.html">
            
                <a href="declaration files/Consumption.html">
            
                    
                    Consumption
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Project Configuration</li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="tsconfig.json.html">
            
                <a href="tsconfig.json.html">
            
                    
                    tsconfig.json
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2" data-path="Compiler Options.html">
            
                <a href="Compiler Options.html">
            
                    
                    Compiler Options
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3" data-path="Compiler Options in MSBuild.html">
            
                <a href="Compiler Options in MSBuild.html">
            
                    
                    Compiler Options in MSBuild
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.4" data-path="Integrating with Build Tools.html">
            
                <a href="Integrating with Build Tools.html">
            
                    
                    Integrating with Build Tools
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.5" data-path="Nightly Builds.html">
            
                <a href="Nightly Builds.html">
            
                    
                    Nightly Builds
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >JSX</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="introduction">Introduction</h1>
<p><a href="https://facebook.github.io/jsx/" target="_blank">JSX</a> is an embeddable XML-like syntax.
It is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific.
JSX came to popularity with the <a href="http://facebook.github.io/react/" target="_blank">React</a> framework, but has since seen other applications as well.
TypeScript supports embedding, type checking, and compiling JSX directly into JavaScript.</p>
<h1 id="basic-usage">Basic usage</h1>
<p>In order to use JSX you must do two things.</p>
<ol>
<li>Name your files with a <code>.tsx</code> extension</li>
<li>Enable the <code>jsx</code> option</li>
</ol>
<p>TypeScript ships with three JSX modes: <code>preserve</code>, <code>react</code>, and <code>react-native</code>.
These modes only affect the emit stage - type checking is unaffected.
The <code>preserve</code> mode will keep the JSX as part of the output to be further consumed by another transform step (e.g. <a href="https://babeljs.io/" target="_blank">Babel</a>).
Additionally the output will have a <code>.jsx</code> file extension.
The <code>react</code> mode will emit <code>React.createElement</code>, does not need to go through a JSX transformation before use, and the output will have a <code>.js</code> file extension.
The <code>react-native</code> mode is the equivalent of <code>preserve</code> in that it keeps all JSX, but the output will instead have a <code>.js</code> file extension.</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Input</th>
<th>Output</th>
<th>Output File Extension</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>preserve</code></td>
<td><code>&lt;div /&gt;</code></td>
<td><code>&lt;div /&gt;</code></td>
<td><code>.jsx</code></td>
</tr>
<tr>
<td><code>react</code></td>
<td><code>&lt;div /&gt;</code></td>
<td><code>React.createElement(&quot;div&quot;)</code></td>
<td><code>.js</code></td>
</tr>
<tr>
<td><code>react-native</code></td>
<td><code>&lt;div /&gt;</code></td>
<td><code>&lt;div /&gt;</code></td>
<td><code>.js</code></td>
</tr>
</tbody>
</table>
<p>You can specify this mode using either the <code>--jsx</code> command line flag or the corresponding option in your <a href="tsconfig.json.html">tsconfig.json</a> file.</p>
<blockquote>
<p><em>Note: The identifier <code>React</code> is hard-coded, so you must make React available with an uppercase R.</em></p>
</blockquote>
<h1 id="the-as-operator">The <code>as</code> operator</h1>
<p>Recall how to write a type assertion:</p>
<pre><code class="lang-ts"><span class="cm-keyword">var</span> <span class="cm-variable">foo</span> <span class="cm-operator">=</span> <span class="cm-operator">&lt;</span><span class="cm-variable">foo</span><span class="cm-operator">&gt;</span><span class="cm-variable">bar</span>;
</code></pre>
<p>Here we are asserting the variable <code>bar</code> to have the type <code>foo</code>.
Since TypeScript also uses angle brackets for type assertions, JSX&apos;s syntax introduces certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in <code>.tsx</code> files.</p>
<p>To make up for this loss of functionality in <code>.tsx</code> files, a new type assertion operator has been added: <code>as</code>.
The above example can easily be rewritten with the <code>as</code> operator.</p>
<pre><code class="lang-ts"><span class="cm-keyword">var</span> <span class="cm-variable">foo</span> <span class="cm-operator">=</span> <span class="cm-variable">bar</span> <span class="cm-variable">as</span> <span class="cm-variable">foo</span>;
</code></pre>
<p>The <code>as</code> operator is available in both <code>.ts</code> and <code>.tsx</code> files, and is identical in behavior to the other type assertion style.</p>
<h1 id="type-checking">Type Checking</h1>
<p>In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements.
Given a JSX expression <code>&lt;expr /&gt;</code>, <code>expr</code> may either refer to something intrinsic to the environment (e.g. a <code>div</code> or <code>span</code> in a DOM environment) or to a custom component that you&apos;ve created.
This is important for two reasons:</p>
<ol>
<li>For React, intrinsic elements are emitted as strings (<code>React.createElement(&quot;div&quot;)</code>), whereas a component you&apos;ve created is not (<code>React.createElement(MyComponent)</code>).</li>
<li>The types of the attributes being passed in the JSX element should be looked up differently.
Intrinsic element attributes should be known <em>intrinsically</em> whereas components will likely want to specify their own set of attributes.</li>
</ol>
<p>TypeScript uses the <a href="http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components" target="_blank">same convention that React does</a> for distinguishing between these.
An intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter.</p>
<h2 id="intrinsic-elements">Intrinsic elements</h2>
<p>Intrinsic elements are looked up on the special interface <code>JSX.IntrinsicElements</code>.
By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked.
However, if this interface <em>is</em> present, then the name of the intrinsic element is looked up as a property on the <code>JSX.IntrinsicElements</code> interface.
For example:</p>
<pre><code class="lang-ts"><span class="cm-variable">declare</span> <span class="cm-variable">namespace</span> <span class="cm-variable">JSX</span> {
    <span class="cm-keyword">interface</span> <span class="cm-variable">IntrinsicElements</span> {
        <span class="cm-variable">foo</span>: <span class="cm-variable-3">any</span>
    }
}

<span class="cm-operator">&lt;</span><span class="cm-variable">foo</span> <span class="cm-operator">/&gt;</span>; <span class="cm-comment">// ok</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">bar</span> <span class="cm-operator">/&gt;</span>; <span class="cm-comment">// error</span>
</code></pre>
<p>In the above example, <code>&lt;foo /&gt;</code> will work fine but <code>&lt;bar /&gt;</code> will result in an error since it has not been specified on <code>JSX.IntrinsicElements</code>.</p>
<blockquote>
<p>Note: You can also specify a catch-all string indexer on <code>JSX.IntrinsicElements</code> as follows:</p>
<pre><code class="lang-ts"><span class="cm-variable">declare</span> <span class="cm-variable">namespace</span> <span class="cm-variable">JSX</span> {
   <span class="cm-keyword">interface</span> <span class="cm-variable">IntrinsicElements</span> {
       [<span class="cm-variable">elemName</span>: <span class="cm-variable-3">string</span>]: <span class="cm-variable-3">any</span>;
   }
}
</code></pre>
</blockquote>
<h2 id="value-based-elements">Value-based elements</h2>
<p>Value based elements are simply looked up by identifiers that are in scope.</p>
<pre><code class="lang-ts"><span class="cm-keyword">import</span> <span class="cm-variable">MyComponent</span> <span class="cm-keyword">from</span> <span class="cm-string">&quot;./myComponent&quot;</span>;

<span class="cm-operator">&lt;</span><span class="cm-variable">MyComponent</span> <span class="cm-operator">/&gt;</span>; <span class="cm-comment">// ok</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">SomeOtherComponent</span> <span class="cm-operator">/&gt;</span>; <span class="cm-comment">// error</span>
</code></pre>
<p>There are two ways to define a value-based element:</p>
<ol>
<li>Stateless Functional Component (SFC)</li>
<li>Class Component</li>
</ol>
<p>Because these two types of value-based elements are indistinguishable from each other in JSX expression, we first try to resolve the expression as Stateless Functional Component using overload resolution. If the process successes, then we are done resolving the expression to its declaration. If we fail to resolve as SFC, we will then try to resolve as a class component. If that fails, we will report an error.</p>
<h3 id="stateless-functional-component">Stateless Functional Component</h3>
<p>As the name suggested, the component is defined as JavaScript function where its first argument is a <code>props</code> object.
We enforce that its return type must be assignable to <code>JSX.Element</code></p>
<pre><code class="lang-ts"><span class="cm-keyword">interface</span> <span class="cm-variable">FooProp</span> {
  <span class="cm-variable">name</span>: <span class="cm-variable-3">string</span>;
  <span class="cm-variable">X</span>: <span class="cm-variable-3">number</span>;
  <span class="cm-variable">Y</span>: <span class="cm-variable-3">number</span>;
}

<span class="cm-variable">declare</span> <span class="cm-keyword">function</span> <span class="cm-variable">AnotherComponent</span>(<span class="cm-def">prop</span>: {<span class="cm-variable">name</span>: <span class="cm-variable-3">string</span>});
<span class="cm-keyword">function</span> <span class="cm-variable">ComponentFoo</span>(<span class="cm-def">prop</span>: <span class="cm-variable-3">FooProp</span>) {
  <span class="cm-keyword">return</span> <span class="cm-operator">&lt;</span><span class="cm-variable">AnotherComponent</span> <span class="cm-variable">name</span><span class="cm-operator">=</span><span class="cm-variable-2">prop</span>.<span class="cm-property">name</span> <span class="cm-operator">/&gt;</span>;
}

<span class="cm-keyword">const</span> <span class="cm-variable">Button</span> <span class="cm-operator">=</span> (<span class="cm-def">prop</span>: {<span class="cm-variable">value</span>: <span class="cm-variable-3">string</span>}, <span class="cm-variable">context</span>: { <span class="cm-variable">color</span>: <span class="cm-variable-3">string</span> }) <span class="cm-operator">=&gt;</span> <span class="cm-operator">&lt;</span><span class="cm-variable">button</span><span class="cm-operator">&gt;</span>
</code></pre>
<p>Because SFC is simply a JavaScript function, we can utilize function overload here as well.</p>
<pre><code class="lang-ts"><span class="cm-keyword">interface</span> <span class="cm-variable">ClickableProps</span> {
  <span class="cm-variable">children</span>: <span class="cm-variable">JSX</span>.<span class="cm-property">Element</span>[] <span class="cm-operator">|</span> <span class="cm-variable">JSX</span>.<span class="cm-property">Element</span>
}

<span class="cm-keyword">interface</span> <span class="cm-variable">HomeProps</span> <span class="cm-keyword">extends</span> <span class="cm-variable">ClickableProps</span> {
  <span class="cm-variable">home</span>: <span class="cm-variable">JSX</span>.<span class="cm-property">Element</span>;
}

<span class="cm-keyword">interface</span> <span class="cm-variable">SideProps</span> <span class="cm-keyword">extends</span> <span class="cm-variable">ClickableProps</span> {
  <span class="cm-variable">side</span>: <span class="cm-variable">JSX</span>.<span class="cm-property">Element</span> <span class="cm-operator">|</span> <span class="cm-variable-3">string</span>;
}

<span class="cm-keyword">function</span> <span class="cm-variable">MainButton</span>(<span class="cm-def">prop</span>: <span class="cm-variable-3">HomeProps</span>): <span class="cm-variable">JSX</span>.<span class="cm-property">Element</span>;
<span class="cm-keyword">function</span> <span class="cm-variable">MainButton</span>(<span class="cm-def">prop</span>: <span class="cm-variable-3">SideProps</span>): <span class="cm-variable">JSX</span>.<span class="cm-property">Element</span> {
  <span class="cm-meta">...</span>
}
</code></pre>
<h3 id="class-component">Class Component</h3>
<p>It is possible to limit the type of a class component.
However, for this we must introduce two new terms: the <em>element class type</em> and the <em>element instance type</em>.</p>
<p>Given <code>&lt;Expr /&gt;</code>, the <em>element class type</em> is the type of <code>Expr</code>.
So in the example above, if <code>MyComponent</code> was an ES6 class the class type would be that class.
If <code>MyComponent</code> was a factory function, the class type would be that function.</p>
<p>Once the class type is established, the instance type is determined by the union of the return types of the class type&apos;s call signatures and construct signatures.
So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.</p>
<pre><code class="lang-ts"><span class="cm-keyword">class</span> <span class="cm-variable">MyComponent</span> {
  <span class="cm-property">render</span>() {}
}

<span class="cm-comment">// use a construct signature</span>
<span class="cm-keyword">var</span> <span class="cm-variable">myComponent</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">MyComponent</span>();

<span class="cm-comment">// element class type =&gt; MyComponent</span>
<span class="cm-comment">// element instance type =&gt; { render: () =&gt; void }</span>

<span class="cm-keyword">function</span> <span class="cm-variable">MyFactoryFunction</span>() {
  <span class="cm-keyword">return</span> {
    <span class="cm-property">render</span>: () <span class="cm-operator">=&gt;</span> {
    }
  }
}

<span class="cm-comment">// use a call signature</span>
<span class="cm-keyword">var</span> <span class="cm-variable">myComponent</span> <span class="cm-operator">=</span> <span class="cm-variable">MyFactoryFunction</span>();

<span class="cm-comment">// element class type =&gt; FactoryFunction</span>
<span class="cm-comment">// element instance type =&gt; { render: () =&gt; void }</span>
</code></pre>
<p>The element instance type is interesting because it must be assignable to <code>JSX.ElementClass</code> or it will result in an error.
By default <code>JSX.ElementClass</code> is <code>{}</code>, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.</p>
<pre><code class="lang-ts"><span class="cm-variable">declare</span> <span class="cm-variable">namespace</span> <span class="cm-variable">JSX</span> {
  <span class="cm-keyword">interface</span> <span class="cm-variable">ElementClass</span> {
    <span class="cm-variable">render</span>: <span class="cm-variable-3">any</span>;
  }
}

<span class="cm-keyword">class</span> <span class="cm-variable">MyComponent</span> {
  <span class="cm-property">render</span>() {}
}
<span class="cm-keyword">function</span> <span class="cm-variable">MyFactoryFunction</span>() {
  <span class="cm-keyword">return</span> { <span class="cm-property">render</span>: () <span class="cm-operator">=&gt;</span> {} }
}

<span class="cm-operator">&lt;</span><span class="cm-variable">MyComponent</span> <span class="cm-operator">/&gt;</span>; <span class="cm-comment">// ok</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">MyFactoryFunction</span> <span class="cm-operator">/&gt;</span>; <span class="cm-comment">// ok</span>

<span class="cm-keyword">class</span> <span class="cm-variable">NotAValidComponent</span> {}
<span class="cm-keyword">function</span> <span class="cm-variable">NotAValidFactoryFunction</span>() {
  <span class="cm-keyword">return</span> {};
}

<span class="cm-operator">&lt;</span><span class="cm-variable">NotAValidComponent</span> <span class="cm-operator">/&gt;</span>; <span class="cm-comment">// error</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">NotAValidFactoryFunction</span> <span class="cm-operator">/&gt;</span>; <span class="cm-comment">// error</span>
</code></pre>
<h2 id="attribute-type-checking">Attribute type checking</h2>
<p>The first step to type checking attributes is to determine the <em>element attributes type</em>.
This is slightly different between intrinsic and value-based elements.</p>
<p>For intrinsic elements, it is the type of the property on <code>JSX.IntrinsicElements</code></p>
<pre><code class="lang-ts"><span class="cm-variable">declare</span> <span class="cm-variable">namespace</span> <span class="cm-variable">JSX</span> {
  <span class="cm-keyword">interface</span> <span class="cm-variable">IntrinsicElements</span> {
    <span class="cm-variable">foo</span>: { <span class="cm-variable">bar</span><span class="cm-operator">?</span>: <span class="cm-variable">boolean</span> }
  }
}

<span class="cm-comment">// element attributes type for &apos;foo&apos; is &apos;{bar?: boolean}&apos;</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">foo</span> <span class="cm-variable">bar</span> <span class="cm-operator">/&gt;</span>;
</code></pre>
<p>For value-based elements, it is a bit more complex.
It is determined by the type of a property on the <em>element instance type</em> that was previously determined.
Which property to use is determined by <code>JSX.ElementAttributesProperty</code>.
It should be declared with a single property.
The name of that property is then used.</p>
<pre><code class="lang-ts"><span class="cm-variable">declare</span> <span class="cm-variable">namespace</span> <span class="cm-variable">JSX</span> {
  <span class="cm-keyword">interface</span> <span class="cm-variable">ElementAttributesProperty</span> {
    <span class="cm-variable">props</span>; <span class="cm-comment">// specify the property name to use</span>
  }
}

<span class="cm-keyword">class</span> <span class="cm-variable">MyComponent</span> {
  <span class="cm-comment">// specify the property on the element instance type</span>
  <span class="cm-property">props</span>: {
    <span class="cm-property">foo</span><span class="cm-operator">?</span>: <span class="cm-variable-3">string</span>;
  }
}

<span class="cm-comment">// element attributes type for &apos;MyComponent&apos; is &apos;{foo?: string}&apos;</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">MyComponent</span> <span class="cm-variable">foo</span><span class="cm-operator">=</span><span class="cm-string">&quot;bar&quot;</span> <span class="cm-operator">/&gt;</span>
</code></pre>
<p>The element attribute type is used to type check the attributes in the JSX.
Optional and required properties are supported.</p>
<pre><code class="lang-ts"><span class="cm-variable">declare</span> <span class="cm-variable">namespace</span> <span class="cm-variable">JSX</span> {
  <span class="cm-keyword">interface</span> <span class="cm-variable">IntrinsicElements</span> {
    <span class="cm-variable">foo</span>: { <span class="cm-variable">requiredProp</span>: <span class="cm-variable-3">string</span>; <span class="cm-variable">optionalProp</span><span class="cm-operator">?</span>: <span class="cm-variable-3">number</span> }
  }
}

<span class="cm-operator">&lt;</span><span class="cm-variable">foo</span> <span class="cm-variable">requiredProp</span><span class="cm-operator">=</span><span class="cm-string">&quot;bar&quot;</span> <span class="cm-operator">/&gt;</span>; <span class="cm-comment">// ok</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">foo</span> <span class="cm-variable">requiredProp</span><span class="cm-operator">=</span><span class="cm-string">&quot;bar&quot;</span> <span class="cm-variable">optionalProp</span><span class="cm-operator">=</span>{<span class="cm-number">0</span>} <span class="cm-string-2">/&gt;; /</span><span class="cm-operator">/</span> <span class="cm-variable">ok</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">foo</span> <span class="cm-operator">/&gt;</span>; <span class="cm-comment">// error, requiredProp is missing</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">foo</span> <span class="cm-variable">requiredProp</span><span class="cm-operator">=</span>{<span class="cm-number">0</span>} <span class="cm-string-2">/&gt;; /</span><span class="cm-operator">/</span> <span class="cm-variable">error</span>, <span class="cm-variable">requiredProp</span> <span class="cm-variable">should</span> <span class="cm-variable">be</span> <span class="cm-variable">a</span> <span class="cm-variable-3">string</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">foo</span> <span class="cm-variable">requiredProp</span><span class="cm-operator">=</span><span class="cm-string">&quot;bar&quot;</span> <span class="cm-variable">unknownProp</span> <span class="cm-operator">/&gt;</span>; <span class="cm-comment">// error, unknownProp does not exist</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">foo</span> <span class="cm-variable">requiredProp</span><span class="cm-operator">=</span><span class="cm-string">&quot;bar&quot;</span> <span class="cm-variable">some</span><span class="cm-operator">-</span><span class="cm-variable">unknown</span><span class="cm-operator">-</span><span class="cm-variable">prop</span> <span class="cm-operator">/&gt;</span>; <span class="cm-comment">// ok, because &apos;some-unknown-prop&apos; is not a valid identifier</span>
</code></pre>
<blockquote>
<p>Note: If an attribute name is not a valid JS identifier (like a <code>data-*</code> attribute), it is not considered to be an error if it is not found in the element attributes type.</p>
</blockquote>
<p>The spread operator also works:</p>
<pre><code class="lang-JSX">var props = { requiredProp: &quot;bar&quot; };
&lt;foo {...props} /&gt;; // ok

var badProps = {};
&lt;foo {...badProps} /&gt;; // error
</code></pre>
<h2 id="children-type-checking">Children Type Checking</h2>
<p>In 2.3, we introduce type checking of <em>children</em>. <em>children</em> is a property in an <em>element attributes type</em> which we have determined from type checking attributes.
Similar to how we use <code>JSX.ElementAttributesProperty</code> to determine the name of <em>props</em>, we use <code>JSX.ElementChildrenAttribute</code> to determine the name of <em>children</em>.
<code>JSX.ElementChildrenAttribute</code> should be declared with a single property.</p>
<pre><code class="lang-ts"><span class="cm-variable">declare</span> <span class="cm-variable">namespace</span> <span class="cm-variable">JSX</span> {
  <span class="cm-keyword">interface</span> <span class="cm-variable">ElementChildrenAttribute</span> {
    <span class="cm-variable">children</span>: {};  <span class="cm-comment">// specify children name to use</span>
  }
}
</code></pre>
<p>Without explicitly specify type of children, we will use default type from <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react" target="_blank">React typings</a>.</p>
<pre><code class="lang-ts"><span class="cm-operator">&lt;</span><span class="cm-variable">div</span><span class="cm-operator">&gt;</span>
  <span class="cm-operator">&lt;</span><span class="cm-variable">h1</span><span class="cm-operator">&gt;</span><span class="cm-variable">Hello</span><span class="cm-operator">&lt;</span><span class="cm-string-2">/h1&gt;</span>
<span class="cm-operator">&lt;</span><span class="cm-string-2">/div&gt;;</span>

<span class="cm-operator">&lt;</span><span class="cm-variable">div</span><span class="cm-operator">&gt;</span>
  <span class="cm-operator">&lt;</span><span class="cm-variable">h1</span><span class="cm-operator">&gt;</span><span class="cm-variable">Hello</span><span class="cm-operator">&lt;</span><span class="cm-string-2">/h1&gt;</span>
  <span class="cm-variable">World</span>
<span class="cm-operator">&lt;</span><span class="cm-string-2">/div&gt;;</span>

<span class="cm-keyword">const</span> <span class="cm-variable">CustomComp</span> <span class="cm-operator">=</span> (<span class="cm-def">props</span>) <span class="cm-operator">=&gt;</span> <span class="cm-operator">&lt;</span><span class="cm-variable">div</span><span class="cm-operator">&gt;</span><span class="cm-variable-2">props</span>.<span class="cm-property">children</span><span class="cm-operator">&lt;</span><span class="cm-string-2">/div&gt;</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">CustomComp</span><span class="cm-operator">&gt;</span>
  <span class="cm-operator">&lt;</span><span class="cm-variable">div</span><span class="cm-operator">&gt;</span><span class="cm-variable">Hello</span> <span class="cm-variable">World</span><span class="cm-operator">&lt;</span><span class="cm-string-2">/div&gt;</span>
  {<span class="cm-string">&quot;This is just a JS expression...&quot;</span> <span class="cm-operator">+</span> <span class="cm-number">1000</span>}
<span class="cm-operator">&lt;</span><span class="cm-string-2">/CustomComp&gt;</span>
</code></pre>
<p>You can specify type of <em>children</em> like any other attribute. This will overwritten default type from <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react" target="_blank">React typings</a>.</p>
<pre><code class="lang-ts"><span class="cm-keyword">interface</span> <span class="cm-variable">PropsType</span> {
  <span class="cm-variable">children</span>: <span class="cm-variable">JSX</span>.<span class="cm-property">Element</span>
  <span class="cm-variable">name</span>: <span class="cm-variable-3">string</span>
}

<span class="cm-keyword">class</span> <span class="cm-variable">Component</span> <span class="cm-keyword">extends</span> <span class="cm-variable">React</span>.<span class="cm-property">Component</span><span class="cm-operator">&lt;</span><span class="cm-variable">PropsType</span>, {}<span class="cm-operator">&gt;</span> {
  <span class="cm-property">render</span>() {
    <span class="cm-keyword">return</span> (
      <span class="cm-operator">&lt;</span><span class="cm-variable">h2</span><span class="cm-operator">&gt;</span>
        <span class="cm-keyword">this</span>.<span class="cm-property">props</span>.<span class="cm-property">children</span>
      <span class="cm-operator">&lt;</span><span class="cm-string-2">/h2&gt;</span>
    )
  }
}

<span class="cm-comment">// OK</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">Component</span><span class="cm-operator">&gt;</span>
  <span class="cm-operator">&lt;</span><span class="cm-variable">h1</span><span class="cm-operator">&gt;</span><span class="cm-variable">Hello</span> <span class="cm-variable">World</span><span class="cm-operator">&lt;</span><span class="cm-string-2">/h1&gt;</span>
<span class="cm-operator">&lt;</span><span class="cm-string-2">/Component&gt;</span>

<span class="cm-comment">// Error: children is of type JSX.Element not array of JSX.Element</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">Component</span><span class="cm-operator">&gt;</span>
  <span class="cm-operator">&lt;</span><span class="cm-variable">h1</span><span class="cm-operator">&gt;</span><span class="cm-variable">Hello</span> <span class="cm-variable">World</span><span class="cm-operator">&lt;</span><span class="cm-string-2">/h1&gt;</span>
  <span class="cm-operator">&lt;</span><span class="cm-variable">h2</span><span class="cm-operator">&gt;</span><span class="cm-variable">Hello</span> <span class="cm-variable">World</span><span class="cm-operator">&lt;</span><span class="cm-string-2">/h2&gt;</span>
<span class="cm-operator">&lt;</span><span class="cm-string-2">/Component&gt;</span>

<span class="cm-comment">// Error: children is of type JSX.Element not array of JSX.Element or string.</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">Component</span><span class="cm-operator">&gt;</span>
  <span class="cm-operator">&lt;</span><span class="cm-variable">h1</span><span class="cm-operator">&gt;</span><span class="cm-variable">Hello</span><span class="cm-operator">&lt;</span><span class="cm-string-2">/h1&gt;</span>
  <span class="cm-variable">World</span>
<span class="cm-operator">&lt;</span><span class="cm-string-2">/Component&gt;</span>
</code></pre>
<h1 id="the-jsx-result-type">The JSX result type</h1>
<p>By default the result of a JSX expression is typed as <code>any</code>.
You can customize the type by specifying the <code>JSX.Element</code> interface.
However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface.
It is a black box.</p>
<h1 id="embedding-expressions">Embedding Expressions</h1>
<p>JSX allows you to embed expressions between tags by surrounding the expressions with curly braces (<code>{ }</code>).</p>
<pre><code class="lang-JSX">var a = &lt;div&gt;
  {[&quot;foo&quot;, &quot;bar&quot;].map(i =&gt; &lt;span&gt;{i / 2}&lt;/span&gt;)}
&lt;/div&gt;
</code></pre>
<p>The above code will result in an error since you cannot divide a string by a number.
The output, when using the <code>preserve</code> option, looks like:</p>
<pre><code class="lang-JSX">var a = &lt;div&gt;
  {[&quot;foo&quot;, &quot;bar&quot;].map(function (i) { return &lt;span&gt;{i / 2}&lt;/span&gt;; })}
&lt;/div&gt;
</code></pre>
<h1 id="react-integration">React integration</h1>
<p>To use JSX with React you should use the <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react" target="_blank">React typings</a>.
These typings define the <code>JSX</code> namespace appropriately for use with React.</p>
<pre><code class="lang-ts"><span class="cm-comment">/// &lt;reference path=&quot;react.d.ts&quot; /&gt;</span>

<span class="cm-keyword">interface</span> <span class="cm-variable">Props</span> {
  <span class="cm-variable">foo</span>: <span class="cm-variable-3">string</span>;
}

<span class="cm-keyword">class</span> <span class="cm-variable">MyComponent</span> <span class="cm-keyword">extends</span> <span class="cm-variable">React</span>.<span class="cm-property">Component</span><span class="cm-operator">&lt;</span><span class="cm-variable">Props</span>, {}<span class="cm-operator">&gt;</span> {
  <span class="cm-property">render</span>() {
    <span class="cm-keyword">return</span> <span class="cm-operator">&lt;</span><span class="cm-variable">span</span><span class="cm-operator">&gt;</span>{<span class="cm-keyword">this</span>.<span class="cm-variable">props</span>.<span class="cm-variable">foo</span>}<span class="cm-operator">&lt;</span><span class="cm-string-2">/span&gt;</span>
  }
}

<span class="cm-operator">&lt;</span><span class="cm-variable">MyComponent</span> <span class="cm-variable">foo</span><span class="cm-operator">=</span><span class="cm-string">&quot;bar&quot;</span> <span class="cm-operator">/&gt;</span>; <span class="cm-comment">// ok</span>
<span class="cm-operator">&lt;</span><span class="cm-variable">MyComponent</span> <span class="cm-variable">foo</span><span class="cm-operator">=</span>{<span class="cm-numbercm-property">0</span>} <span class="cm-string-2">/&gt;; /</span><span class="cm-operator">/</span> <span class="cm-variable">error</span>
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Declaration Merging.html" class="navigation navigation-prev " aria-label="Previous page: Declaration Merging">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Decorators.html" class="navigation navigation-next " aria-label="Next page: Decorators">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"JSX","level":"3.18","depth":1,"next":{"title":"Decorators","level":"3.19","depth":1,"path":"pages/Decorators.md","ref":"pages/Decorators.md","articles":[]},"previous":{"title":"Declaration Merging","level":"3.17","depth":1,"path":"pages/Declaration Merging.md","ref":"pages/Declaration Merging.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["theme-darkblue","addcssjs","highlight-1","custom-favicon"],"pluginsConfig":{"search":{},"addcssjs":{"js":[],"css":["assets/css/atom-one-dark.css"]},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-darkblue":{},"highlight":{},"favicon":"assets/images/favicon.ico","highlight-1":{},"custom-favicon":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"pages/JSX.md","mtime":"2018-03-08T10:41:28.574Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-03-11T12:37:57.657Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    

    </body>
</html>

